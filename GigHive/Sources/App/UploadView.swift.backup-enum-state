import SwiftUI
import UniformTypeIdentifiers

struct LabeledField<Content: View>: View {
    let label: String
    let helper: String?
    @ViewBuilder var content: Content

    init(_ label: String, helper: String? = nil, @ViewBuilder content: () -> Content) {
        self.label = label
        self.helper = helper
        self.content = content()
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 6) {
            GHLabel(text: label)
            content
            if let helper, !helper.isEmpty {
                Text(helper).font(.footnote).ghForeground(GHTheme.muted)
            }
        }
    }
}

struct UploadView: View {
    // SERVER
    @AppStorage("gh_server_url") private var serverURLString: String = "https://gighive" // editable by user
    @AppStorage("gh_basic_user") private var username: String = ""
    @AppStorage("gh_basic_pass") private var password: String = ""
    @AppStorage("gh_eventType_default") private var storedEventType: String = "band"

    @State private var fileURL: URL?
    @State private var eventDate = Date()
    @State private var orgName = ""
    @State private var eventType = "band"
    @State private var label = ""
    @State private var autogenLabel = false
    @State private var showPhotosPicker = false
    @State private var showFilesPicker = false
    @State private var isUploading = false
    @State private var isCancelling = false
    @State private var showResultAlert = false
    @State private var alertTitle = ""
    @State private var alertMessage = ""
    @State private var debugLog: [String] = []
    @State private var successURL: URL?
    @State private var failureCount: Int = 0
    @State private var uploadTask: Task<Void, Never>? = nil
    @State private var lastButtonStatus: String? = nil
    @State private var currentUploadClient: UploadClient? = nil
    @State private var allowInsecureTLS = false
    @State private var isLoadingMedia = false
    @State private var loadedFileSize: String? = nil
    // Ensure loading text is visible for at least a minimum duration
    @State private var mediaLoadingStartedAt: Date? = nil
    @State private var lastProgressBucket: Int = 0

    let onUpload: (UploadPayload) -> Void
    @Environment(\.openURL) private var openURL

    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 10) {
                HStack(spacing: 8) {
                    Image("beelogo")
                        .resizable()
                        .scaledToFit()
                        .frame(height: UIFont.preferredFont(forTextStyle: .title2).pointSize + 2)
                    Text("Gighive Upload")
                        .font(.title3).bold()
                        .ghForeground(GHTheme.text)
                }

                // SERVER CARD
                GHCard(pad: 8) {
                    VStack(alignment: .leading, spacing: 2) {
                        GHLabel(text: "SERVER")

                        LabeledField("") {
                            TextField("https://example.com", text: $serverURLString)
                                .keyboardType(.URL)
                                .ghNoAutocapitalization()
                                .disableAutocorrection(true)
                                .font(.footnote)
                                .padding(.vertical, 2)
                                .padding(.horizontal, 8)
                                .ghForeground(GHTheme.text)
                                .ghTint(GHTheme.caret)
                                .ghBackgroundMaterial()
                                .cornerRadius(6)
                                .frame(height: 24)
                        }

                        LabeledField("Username *") {
                            TextField("admin/uploader username", text: $username)
                                .keyboardType(.default)
                                .ghNoAutocapitalization()
                                .disableAutocorrection(true)
                                .font(.footnote)
                                .padding(.vertical, 3)
                                .padding(.horizontal, 8)
                                .ghForeground(GHTheme.text)
                                .ghTint(GHTheme.caret)
                                .ghBackgroundMaterial()
                                .cornerRadius(6)
                                .frame(height: 28)
                        }

                        LabeledField("Password *") {
                            SecureField("password", text: $password)
                                .keyboardType(.default)
                                .ghNoAutocapitalization()
                                .disableAutocorrection(true)
                                .font(.footnote)
                                .padding(.vertical, 3)
                                .padding(.horizontal, 8)
                                .ghForeground(GHTheme.text)
                                .ghTint(GHTheme.caret)
                                .ghBackgroundMaterial()
                                .cornerRadius(6)
                                .frame(height: 28)
                        }

                        // Default event type removed from SERVER: we persist the META selection instead.
                    }
                }

                GHCard(pad: 8) {
                    VStack(alignment: .leading, spacing: 6) {

                        LabeledField("Media file (audio/video) *") {
                            Menu {
                                Button("From Photos", action: { 
                                    loadedFileSize = nil  // Clear previous file size
                                    isLoadingMedia = true  // Show loading immediately when dropdown option is touched
                                    showPhotosPicker = true 
                                })
                                Button("From Files", action: { 
                                    loadedFileSize = nil  // Clear previous file size
                                    isLoadingMedia = true  // Show loading immediately when dropdown option is touched
                                    showFilesPicker = true 
                                })
                            } label: {
                                HStack {
                                    Image(systemName: "paperclip")
                                    Text(fileURL?.lastPathComponent ?? "Choose File")
                                        .lineLimit(1)
                                }
                                .padding(.vertical, 8)
                                .padding(.horizontal, 10)
                                .background(
                                    RoundedRectangle(cornerRadius: 10)
                                        .stroke(GHTheme.accent, lineWidth: 1.5)
                                        .background(GHTheme.card.opacity(0.3))
                                )
                                .cornerRadius(10)
                            }
                            if isLoadingMedia || (fileURL != nil && loadedFileSize == nil) {
                                Text("Loading media metadataâ€¦please wait until file size is displayed.")
                                    .font(.caption2)
                                    .foregroundColor(.red)
                            } else if let fileSize = loadedFileSize {
                                Text("File size: \(fileSize)")
                                    .font(.caption2)
                                    .foregroundColor(.red)
                            }
                        }

                        LabeledField("Event date *") {
                            DatePicker("", selection: $eventDate, displayedComponents: .date)
                                .labelsHidden()
                                .datePickerStyle(CompactDatePickerStyle())
                                .ghForeground(GHTheme.text)
                                .environment(\.colorScheme, .dark)
                        }

                        LabeledField("Band or wedding party name *") {
                            TextField("", text: $orgName)
                                .keyboardType(.default)
                                .ghWordsAutocap()
                                .disableAutocorrection(true)
                                .font(.footnote)
                                .padding(.vertical, 2)
                                .padding(.horizontal, 8)
                                .ghForeground(GHTheme.text)
                                .ghTint(GHTheme.caret)
                                .ghBackgroundMaterial()
                                .cornerRadius(6)
                                .frame(height: 24)
                        }

                        LabeledField("Event type *") {
                            Picker("", selection: $eventType) {
                                Text("band").tag("band")
                                Text("wedding").tag("wedding")
                            }
                            .pickerStyle(.segmented)
                        }

                        LabeledField("Song title or wedding table / identifier *") {
                            TextField("", text: $label)
                                .keyboardType(.default)
                                .disableAutocorrection(true)
                                .font(.footnote)
                                .padding(.vertical, 2)
                                .padding(.horizontal, 8)
                                .ghForeground(GHTheme.text)
                                .ghTint(GHTheme.caret)
                                .ghBackgroundMaterial()
                                .cornerRadius(6)
                                .frame(height: 24)
                        }

                        Toggle(isOn: $autogenLabel) {
                            GHLabel(text: "Autogenerate label?")
                        }
                        .ghTint(GHTheme.accent)

                        if autogenLabel {
                            Text("If checked, the label will be set to \"Auto YYYY-MM-DD\" based on the Event date.")
                                .ghForeground(GHTheme.muted)
                        }

                        Button(isCancelling ? "Cancellingâ€¦" : (isUploading ? "Uploadingâ€¦" : (lastButtonStatus ?? "Upload")), action: {
                            if isUploading {
                                // Second press: cancel
                                isCancelling = true
                                debugLog.append("cancellingâ€¦")
                                uploadTask?.cancel()
                                
                                // Also cancel the underlying network upload task
                                currentUploadClient?.cancelCurrentUpload()
                            } else {
                                doUpload()
                            }
                        })
                            .buttonStyle(GHButtonStyle(color: lastButtonStatus == "Upload Cancelled" ? .red : GHTheme.accent))
                            .disabled((!isUploading) && (isLoadingMedia || fileURL == nil || (label.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)))
                            .padding(.top, 2)

                        // Validation messages for mandatory fields
                        if !isUploading && !isLoadingMedia {
                            let validationMessages = getValidationMessages()
                            if !validationMessages.isEmpty {
                                VStack(alignment: .leading, spacing: 2) {
                                    ForEach(validationMessages, id: \.self) { message in
                                        Text("âš ï¸ \(message)")
                                            .font(.caption2)
                                            .foregroundColor(.orange)
                                    }
                                }
                                .padding(.top, 2)
                            }
                        }

                        if !debugLog.isEmpty {
                            Text(debugLog.joined(separator: " â†’ "))
                                .font(.caption2)
                                .foregroundColor(.red)
                                .padding(.top, 2)
                        }


                        if let url = successURL {
                            Link("View in database", destination: url)
                                .font(.caption)
                                .ghForeground(GHTheme.accent)
                                .padding(.top, 2)
                        }

                        Toggle(isOn: $allowInsecureTLS) {
                            Text("Disable Certificate Checking").font(.caption2).ghForeground(GHTheme.muted)
                        }
                        .ghTint(GHTheme.accent)
                        .padding(.top, 4)

                        Button(action: hideKeyboard) {
                            Text("Hide Keyboard").font(.caption)
                        }
                        .padding(.top, 2)

                        if failureCount >= 5 {
                            if let mail = makeSupportEmailLink() {
                                Link("Email administrator with debug log", destination: mail)
                                    .font(.caption)
                                    .foregroundColor(.red)
                                    .padding(.top, 2)
                            }
                        }
                    }
                }
            }
            .frame(maxWidth: .infinity, alignment: .topLeading)
            .padding(8)
        }
        .ghFullScreenBackground(GHTheme.bg)
        .sheet(isPresented: $showPhotosPicker) {
            PHPickerView { url in
                // Clear old debug log when selecting new file
                debugLog = []

                // Show loading immediately upon a valid selection, then dismiss picker
                if let url = url {
                    // Mark the start moment and show loading immediately
                    self.mediaLoadingStartedAt = Date()
                    self.isLoadingMedia = true
                    self.loadedFileSize = nil
                    self.fileURL = url
                    self.showPhotosPicker = false
                    debugLog.append("reading file metadata...")

                    // Compute file size and only clear loading after minimum visible duration
                    DispatchQueue.global(qos: .userInitiated).async {
                        debugLog.append("calculating file size...")
                        let minVisible: TimeInterval = 1.0
                        let sizeText: String = {
                            do {
                                let bytes = try url.resourceValues(forKeys: [.fileSizeKey]).fileSize ?? 0
                                return ByteCountFormatter.string(fromByteCount: Int64(bytes), countStyle: .file)
                            } catch {
                                return "unknown"
                            }
                        }()
                        let started = self.mediaLoadingStartedAt ?? Date()
                        let elapsed = Date().timeIntervalSince(started)
                        let remaining = max(0, minVisible - elapsed)
                        DispatchQueue.main.asyncAfter(deadline: .now() + remaining) {
                            self.loadedFileSize = sizeText
                            self.isLoadingMedia = false
                            self.mediaLoadingStartedAt = nil
                            debugLog.append("file metadata loaded (\(sizeText))")
                            debugLog.append("picked from Photos")
                        }
                    }
                } else {
                    // User cancelled
                    self.showPhotosPicker = false
                    self.fileURL = nil
                    self.loadedFileSize = nil
                    self.isLoadingMedia = false
                    debugLog.append("photos canceled")
                }
            }
            .modifier(PresentationDetentsCompat())
        }
        .sheet(isPresented: $showFilesPicker) {
            DocumentPickerView(
                allowedTypes: [
                    UTType.movie,
                    UTType.mpeg4Movie,
                    UTType.audio,
                    UTType.mp3
                ],
                onPick: { url in
                    // Clear old debug log when selecting new file
                    debugLog = []

                    // Show loading immediately upon a valid selection, then dismiss picker
                    if let url = url {
                        // Mark the start moment and show loading immediately
                        self.mediaLoadingStartedAt = Date()
                        self.isLoadingMedia = true
                        self.loadedFileSize = nil
                        self.fileURL = url
                        self.showFilesPicker = false
                        debugLog.append("reading file metadata...")

                        // Compute file size and only clear loading after minimum visible duration
                        DispatchQueue.global(qos: .userInitiated).async {
                            debugLog.append("calculating file size...")
                            let minVisible: TimeInterval = 1.0
                            let sizeText: String = {
                                do {
                                    let bytes = try url.resourceValues(forKeys: [.fileSizeKey]).fileSize ?? 0
                                    return ByteCountFormatter.string(fromByteCount: Int64(bytes), countStyle: .file)
                                } catch {
                                    return "unknown"
                                }
                            }()
                            let started = self.mediaLoadingStartedAt ?? Date()
                            let elapsed = Date().timeIntervalSince(started)
                            let remaining = max(0, minVisible - elapsed)
                            DispatchQueue.main.asyncAfter(deadline: .now() + remaining) {
                                self.loadedFileSize = sizeText
                                self.isLoadingMedia = false
                                self.mediaLoadingStartedAt = nil
                                debugLog.append("file metadata loaded (\(sizeText))")
                                debugLog.append("picked from Files")
                            }
                        }
                    } else {
                        // User cancelled
                        self.showFilesPicker = false
                        self.fileURL = nil
                        self.loadedFileSize = nil
                        self.isLoadingMedia = false
                        debugLog.append("files canceled")
                    }
                }
            )
            .modifier(PresentationDetentsCompat())
        }
        .onChange(of: autogenLabel) { on in if on { label = autoLabel() }; resetCancelledStatus() }
        .onChange(of: eventDate) { _ in if autogenLabel { label = autoLabel() }; resetCancelledStatus() }
        .onChange(of: eventType) { newValue in
            // Persist META selection across app launches
            storedEventType = newValue
            resetCancelledStatus()
        }
        .onChange(of: fileURL) { _ in resetCancelledStatus() }
        .onChange(of: orgName) { _ in resetCancelledStatus() }
        .onChange(of: label) { _ in resetCancelledStatus() }
        .onChange(of: serverURLString) { _ in resetCancelledStatus() }
        .onChange(of: username) { _ in resetCancelledStatus() }
        .onChange(of: password) { _ in resetCancelledStatus() }
        .onAppear {
            // Initialize META picker from the last used value
            eventType = storedEventType
        }
    }

    private func autoLabel() -> String {
        let df = DateFormatter()
        df.dateFormat = "yyyy-MM-dd"
        return "Auto \(df.string(from: eventDate))"
    }

    private func getValidationMessages() -> [String] {
        var messages: [String] = []
        
        // Check username
        if username.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
            messages.append("Username is required")
        }
        
        // Check password
        if password.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
            messages.append("Password is required")
        }

        // Check media file
        if fileURL == nil {
            messages.append("Please select a media file")
        }
                
        // Check organization name
        if orgName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
            messages.append("Band or wedding party name is required")
        }
        
        // Check label (only if autogenerate is not checked)
        if !autogenLabel && label.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
            messages.append("Song title or wedding identifier is required")
        }
        
        return messages
    }

    // Reset the temporary cancelled label back to default when user edits anything
    private func resetCancelledStatus() {
        if lastButtonStatus == "Upload Cancelled" {
            lastButtonStatus = nil
        }
    }

    private func doUpload() {
        debugLog = ["button pressed"]
        guard let fileURL else { debugLog.append("no file chosen"); alertTitle = "Missing file"; alertMessage = "Please choose a media file from Photos or Files."; showResultAlert = true; return }
        
        // Add file size to debug log
        do {
            let fileSize = try fileURL.resourceValues(forKeys: [.fileSizeKey]).fileSize ?? 0
            let fileSizeText = ByteCountFormatter.string(fromByteCount: Int64(fileSize), countStyle: .file)
            debugLog.append("file size: \(fileSizeText)")
        } catch {
            debugLog.append("file size: unknown")
        }
        
        guard let base = URL(string: serverURLString) else { debugLog.append("invalid server url"); alertTitle = "Invalid Server URL"; alertMessage = "Please enter a valid https:// server URL."; showResultAlert = true; return }
        let payload = UploadPayload(
            fileURL: fileURL,
            eventDate: eventDate,
            orgName: orgName,
            eventType: eventType,
            label: label.isEmpty ? nil : label,
            participants: nil, keywords: nil, location: nil, rating: nil, notes: nil
        )
        // Build client using the provided server credentials
        let client = UploadClient(baseURL: base, basicAuth: (username, password), useBackgroundSession: false, allowInsecure: allowInsecureTLS)
        currentUploadClient = client  // Store reference for cancellation
        isUploading = true
        isCancelling = false
        lastButtonStatus = nil
        lastProgressBucket = 0  // Reset progress tracking for new upload
        uploadTask = Task { [serverURLString, orgName, eventType, label] in
            defer { 
                isUploading = false
                isCancelling = false  // Always reset cancelling state when task ends
                loadedFileSize = nil  // Clear file size display after upload completes/cancels
                currentUploadClient = nil  // Clear client reference
            }
            do {
                debugLog.append("contacting server \(serverURLString)")
                // Pre-log the exact request URL to place progress after this line
                let apiURL = base
                    .appendingPathComponent("api")
                    .appendingPathComponent("uploads.php")
                var comps = URLComponents(url: apiURL, resolvingAgainstBaseURL: false)
                comps?.queryItems = [URLQueryItem(name: "ui", value: "json")]
                if let u = comps?.url { debugLog.append("url=\(u.absoluteString)") }
                
                // Show initial progress to let user know progress tracking is active
                debugLog.append("0%..")

                let (status, data, requestURL) = try await client.uploadWithChunking(payload, progress: { completed, total in
                    // Special case: -1, -1 means Layer 1 assembly in progress (show dots)
                    if completed == -1 && total == -1 {
                        DispatchQueue.main.async {
                            debugLog.append(".")
                        }
                        return
                    }
                    
                    guard total > 0 else { 
                        print("âš ï¸ Progress callback: total is 0")
                        return 
                    }
                    let percent = Int((Double(completed) / Double(total)) * 100.0)
                    let bucket = (percent / 10) * 10
                    print("ðŸ“ˆ UploadView Progress: \(completed)/\(total) bytes = \(percent)%, bucket=\(bucket), lastBucket=\(lastProgressBucket)")
                    if bucket >= 10 && bucket > lastProgressBucket {
                        DispatchQueue.main.async {
                            lastProgressBucket = bucket
                            debugLog.append("\(bucket)%..")
                            print("âœ… Added progress to debug log: \(bucket)%")
                        }
                    }
                })
                debugLog.append("payload=org=\(orgName), type=\(eventType), label=\(label.isEmpty ? "(nil)" : label)")
                debugLog.append("upload finished [\(status)]")
                let bodyText = String(data: data, encoding: .utf8) ?? "(no body)"
                switch status {
                case 201:
                    alertTitle = "Success"
                    alertMessage = "Upload succeeded."
                    let baseURL = base.appendingPathComponent("db").appendingPathComponent("database.php")
                    // Add cache-busting timestamp
                    var components = URLComponents(url: baseURL, resolvingAgainstBaseURL: false)
                    components?.queryItems = [URLQueryItem(name: "t", value: String(Int(Date().timeIntervalSince1970)))]
                    let url = components?.url ?? baseURL
                    successURL = url
                    failureCount = 0
                    // Prepend success message to debug log
                    debugLog.insert("UPLOAD SUCCESSFUL!", at: 0)
                    debugLog.append("db link=\(url.absoluteString)")
                    // Clear fields after success (update UI on main thread)
                    DispatchQueue.main.async {
                        self.fileURL = nil
                        self.label = ""
                    }
                    debugLog.append("cleared file and label")
                    debugLog.append("\n\nYou are free to upload another file.")
                case 401:
                    alertTitle = "Unauthorized"
                    alertMessage = "401 Unauthorized. Check Basic Auth username/password."
                    failureCount += 1
                case 413:
                    alertTitle = "Too Large"
                    alertMessage = "413 Payload Too Large. Pick a smaller file or increase server limits."
                    failureCount += 1
                case 400:
                    alertTitle = "Bad Request"
                    alertMessage = bodyText
                    failureCount += 1
                default:
                    alertTitle = "HTTP \(status)"
                    alertMessage = bodyText
                    failureCount += 1
                }
            } catch is CancellationError {
                // Task was cancelled by user
                debugLog.append("cancelled")
                lastButtonStatus = "Upload Cancelled"
                // Clear selected file after cancellation
                DispatchQueue.main.async {
                    self.fileURL = nil
                }
                // Reset back to default after 5 seconds
                DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                    if lastButtonStatus == "Upload Cancelled" {
                        lastButtonStatus = nil
                    }
                }
                return
            } catch {
                // Map URLError.cancelled to a user-initiated cancel as well
                if let urlErr = error as? URLError, urlErr.code == .cancelled {
                    debugLog.append("cancelled")
                    lastButtonStatus = "Upload Cancelled"
                    // Clear selected file after cancellation
                    DispatchQueue.main.async {
                        self.fileURL = nil
                    }
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        if lastButtonStatus == "Upload Cancelled" {
                            lastButtonStatus = nil
                        }
                    }
                    return
                }
                debugLog.append("error: \(error.localizedDescription)")
                alertTitle = "Error"
                alertMessage = error.localizedDescription
                failureCount += 1
            }
            showResultAlert = true
            onUpload(payload)
        }
    }

    private func makeSupportEmailLink() -> URL? {
        let to = "admin@gighive.local" // TODO: replace with real admin address
        let subject = "GigHive iOS Upload Help"
        let body = (debugLog + ["server=\(serverURLString)", "user=\(username)"]).joined(separator: "\n")
        let enc: (String) -> String = { $0.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? $0 }
        return URL(string: "mailto:\(to)?subject=\(enc(subject))&body=\(enc(body))")
    }

    private func hideKeyboard() {
        // iOS 14 safe keyboard dismissal
        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
    }
}
